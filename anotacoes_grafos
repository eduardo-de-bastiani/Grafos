# Grafos
## Conjunto de v√©rtices (pontos) conectados por arestas (linhas)
Todas as Estruturas de Dados podem ser representadas por Grafos

Grafo n√£o representa uma distribui√ß√£o visual da realidade

___

## Terminologia dos Grafos:
- Grau: quantidade de arestas que saem de um v√©rtice
- Caminho: Sequ√™ncia de v√©rtices conectados por arestas
- Ciclo: Caminho cujos primeiros e √∫ltimos v√©rtices s√£o os mesmos (caminho fechado)

Grafos podem estar "quebrados" em alguns pontos, por isso temos redund√¢ncias.

___
## Problemas nos Grafos:
- Caminho entre start e final
	- existe um caminho entre start e final?
	
- Caminho mais curto
	- qual o menor caminho entre start e final? (dijkstra algorithm)

- Detec√ß√£o de Ciclos
	- existe um ciclo no grafo?

- Ciclo de Hamilton
	- ciclo que usa cada v√©rtice exatamente uma vez

- Ciclo de Euler
	- ciclo que usa cada aresta exatamente uma vez

<img src="https://sumantmath.wordpress.com/wp-content/uploads/2020/07/eulerian-v-shamiltonian-circuits.png" alt="drawing" width="500"/>

- Conectividade
	- existe uma forma de conectar todos os v√©rtices?

- Biconectividade
	- se uma conex√£o √© removida e o v√©rtice ainda √© acess√≠vel, ele √© Biconexo

- Planaridade
	- grafo pode ser desenhado sem cruzamento de arestas?

- Isomorfismo
	- grafos com conex√µes iguais, por√©m de formas diferentes
	
___
	
## Problema da Ponte de K√∂nigsberg
- se um v√©rtice tem grau √≠mpar, n√£o podemos partir dele e chegar nele ao usar todas as arestas
- apenas os graus dos v√©rtices de start e final podem ser √≠mpares

___

## Grafos Dirigidos (possui arestas de dire√ß√£o)
S√≥ pode ir em uma dire√ß√£o espec√≠fica

**Outdegree** = quantidade de graus (arestas) de sa√≠da

**Indegree** = quantidade de graus (arestas) de chegada

___

## Fun√ß√µes Grafos:
- Graph()				--> cria um grafo vazio
- Graph(filename) 		--> cria um grafo a partir de um arquivo de entrada
- addEdge(v, w) 			--> adiciona uma aresta v-w
- string[] getAdj(v)		--> vertices adjacentes (vizinhos) a v
- totalV() 				--> numero de v√©rtices
- totalE()				--> numero de arestas
- string[] getVerts()	--> lista de v√©rtices


**Complexidade O(v) (v√©rtices) √© melhor que O(a) (arestas)**

___


# Estrutura mais eficiente para representar Grafos: 
## LISTA DE ADJAC√äNCIAS
- funciona de forma similar ao hashing
- a complexidade √© O (grau de v) (v√©rtices)
- vai ter redund√¢ncia

___
## BUSCA EM PROFUNDIDADE (DFS)
[Anima√ß√£o DFS](https://algs4.cs.princeton.edu/lectures/demo/41DemoDepthFirstSearch.mov)

- **objetivo**: passar por todo o grafo
	+ **aplica√ß√£o**: encontrar um caminho entre dois v√©rtices / encontrar todos os v√©rtices conectados a um determinado v√©rtice
- marca um v√©rtice como visitado, e recursivamente visita o v√©rtice adjacente (vizinho) n√£o marcado (UM POR VEZ) at√© ficar 'done'
- para procuramos a origem, come√ßamos no v√©rtice de destino, e vemos a coluna EdgeTo() que diz de qual v√©rtice viemos
> estruturas usadas: **marked[]** e **edgeTo[]**







## BUSCA EM LARGURA (BFS)

[Anima√ß√£o BFS](https://algs4.cs.princeton.edu/lectures/demo/41DemoBreadthFirstSearch.mov)
- adiciona o v√©rtice em uma **FILA**
- remove o v√©rtice visitado da fila
- colocamos os vizinhos do vertice visitado no momento na fila.
- atualiza o edgeTo[] e distTo[] dos v√©rtices vizinhos.
- Para cada v√©rtice visitado, removemos o mesmo da fila.
- A ordem de visita√ß√£o √© do v√©rtice mais pr√≥ximo ao v√©rtice mais distante.
- distTo[] √© a dist√¢ncia at√© a origem (primeiro v√©rtice visitado)
- n√£o h√° repeti√ß√µes
- BFS se preocupa com o caminho com menos v√©rtices (n√£o necessariamente o mais curto)!!
> estruturas usadas: **edgeTo[]**,**distTo[]** e **queue**
- exemplo de BFS: grafo do Kevin Bacon
___

## Ordena√ß√£o Topol√≥gica
[Anima√ß√£o Ordena√ß√£o Topol√≥gica](https://algs4.cs.princeton.edu/lectures/demo/42DemoTopologicalSort.mov)

**PROIBIDO FORMAR CICLO!!!**

- usa apenas DFS

- grafo **dirigido** com ordem de **preced√™ncia**
	- ex: disciplinas de um curso 

- **<ins>Pr√© Ordem:<ins>** ordem de ida da DFS

- **<ins>P√≥s Ordem:<ins>** ordem de retorno da DFS

- mesmo n√£o tendo caminho, devemos visitar todos os v√©rtices (for externo)

- **<ins>Ordem Topol√≥gica<ins>** √© o **reverso** do p√≥s ordem. Fazemos o caminho inverso e descobrimos qual a ordem de preced√™ncia das arestas.
	- n√£o h√° problema haver mais de um final
>estruturas usadas: marked[]
	
___

## √Årvore Geradora M√≠nima (MST)

**PROIBIDO FORMAR CICLO!!!**

- Tenta gerar um grafo com os caminhos **mais baratos** para conectar **TODOS** os v√©rtices
	- cada aresta possui um **peso (custo)**

- Caracter√≠sticas:
	- sub-grafo (mesma quantidade de v√©rtices, mas menos arestas)
	- conectado
	- ac√≠clico
	- deve incluir todos os v√©rtices 


### Algoritmo de Kruskal
[Animacao Kruskal](https://drive.google.com/file/d/1cigZzmfqAQFTZGKSZmRe-YcqtvMioWda/view?usp=sharing)

- colocamos todos as arestas com seus respectivos vertices e pesos em **ordem crescente de peso**
- construimos a MST a partir da aresta de menor peso
- **a constru√ß√£o √© desconexa** (v√°rias areastas s√£o criadas em diferentes pontos do grafo)	
	- do menor ao maior peso
- lembrando que **n√£o podem haver ciclos!!**

Exemplo de Algoritmo de Kruskal:
<img src="/home/eduardo/OneDrive/3¬∞ Semestre/ALEST II/Grafos/Images/WhatsApp Image 2024-06-29 at 12.17.16.jpeg" width=900>

### Algoritmo de Prim
- come√ßa pela aresta menos custosa
- verifica qual a aresta mais barata entre os vertices conectados e a conecta
- **a constru√ß√£o √© conectada** (s√≥ podemos criar arestas a partir de v√©rtices que j√° foram conectados)

#### Como encontrar um ciclo?? ‚≠ï 
- usamos uma estrutura similar ao union-find, onde os elementos tem um **marcador da raiz/conjunto**
- se, antes de colocarmos uma aresta entre dois v√©rtices, eles possu√≠rem a mesma ra√≠z (fazem parte do mesmo conjunto), <ins>temos um ciclo!!<ins>

___

## Caminho M√≠nimo
- menor custo (distancia) de um ponto a todos os outros
	- diferente do BFS (busca caminho com menos v√©rtices)

Tipos:
- **<ins>Single source:<ins>** de um v√©rtice *s* para todos os demais (origem fixa)
- **<ins>Single sink:<ins>** de cada v√©rtice para um v√©rtice espec√≠fico *t* (detino fixo)
- **<ins>Source-sink:<ins>** de um v√©rtice *s* para outro *t* (origem e destino fixos)
- **<ins>All pairs:<ins>** entre todos os pares de v√©rtices

GPS usam Single sink (pode haver rec√°lculo de rota)

- SEM CICLOS!

### Algoritmo de Dijkstra üí†

1. inicializa todas as distTo[] de todos os v√©rtices com infinito positivo

2. escolhe um v√©rtice source

3. verifica todos os caminhos para os vizinhos

4. atualiza os caminhos somados ao distTo[]

5. atualiza os edgeTo[]

6. seleciona o menor caminho de qualquer v√©rtice

7. repete os passos 3 a 6 (faz isso para todos os caminhos poss√≠veis)

> Para grafos densos (muitas arestas), o Floyd Warshall √© melhor, mesmo sendo O(n¬≥)

### Relaxamento (‚ûø --> ‚û∞)

Relaxamento √© o **cora√ß√£o** do Algoritmo de Dijkstra:

- quando um caminho mais barato (menor) √© encontrado, ele troca o distTo[], o edgeTo[] e altera a fila de prioridade do novo caminho at√© o v√©rtice


___

## Caminho Cr√≠tico

[v√≠deo caminho cr√≠tico](https://www.youtube.com/watch?v=t6KVR80B7Dc)

- maior caminho (caminho cr√≠tico) determina o menor tempo necess√°rio para completar as tarefas

- **Forward** ir√° calcular o menor tempo de finaliza√ß√£o das tarefas

**Regra 1 Forward:**
- propaga o tempo de uma tarefa para as demais

<img src="/home/eduardo/OneDrive/3¬∞ Semestre/ALEST II/Grafos/Images/Screenshot from 2024-06-23 21-44-03.png" width= 500>

**Regra 2 Forward:**
- propaga o **maior** numero para a proxima tarefa

<img src="/home/eduardo/OneDrive/3¬∞ Semestre/ALEST II/Grafos/Images/Screenshot from 2024-06-23 21-47-27.png" width= 500>

**Regra 1 Backward:**
- propaga o tempo de uma tarefa para as demais
<img src="/home/eduardo/OneDrive/3¬∞ Semestre/ALEST II/Grafos/Images/Screenshot from 2024-06-23 21-51-53.png" width= 500>

**Regra 2 Backward:**
- propaga o **menor** numero para a proxima tarefa
<img src="/home/eduardo/OneDrive/3¬∞ Semestre/ALEST II/Grafos/Images/Screenshot from 2024-06-23 21-50-33.png" width= 500>

>Se a diferen√ßa entre o *start time* e o *finish time* for == 0, a tarefa √© **cr√≠tica**. Se a diferen√ßa for != 0, a tarefa √© n√£o cr√≠tica.

**Exemplo:**

<img src="/home/eduardo/OneDrive/3¬∞ Semestre/ALEST II/Grafos/Images/Screenshot from 2024-06-23 22-08-09.png" width=600>